[
  {
    "id": "post-1",
    "threadId": "thread-1",
    "authorId": "user-student-2",
    "content": "I found the bug! You need to add 1 when updating `left` and subtract 1 when updating `right`. Change:\n\n```python\nleft = mid  # wrong\nright = mid  # wrong\n```\n\nto:\n\n```python\nleft = mid + 1\nright = mid - 1\n```\n\nThe problem is that when you do `left = mid`, you're not actually moving the search window. If mid=2 and the target is greater than arr[2], setting left=2 means you'll check arr[2] again on the next iteration. This creates an infinite loop in some cases.\n\nWith `left = mid + 1`, you're saying \"the answer must be to the right of mid\" and actually excluding mid from future searches. Same logic for `right = mid - 1`.\n\nTry it now and it should work!",
    "endorsed": false,
    "flagged": false,
    "createdAt": "2025-09-13T17:12:26.013Z",
    "updatedAt": "2025-09-13T18:12:26.013Z"
  },
  {
    "id": "post-2",
    "threadId": "thread-2",
    "authorId": "user-ta-3",
    "content": "Great question about the call stack! Let me walk you through what's happening step by step.\n\nWhen you call `factorial(5)`, Python doesn't immediately calculate the answer. Instead, it sees that it needs `5 * factorial(4)`, so it pauses the current function and calls `factorial(4)`. That function needs `4 * factorial(3)`, so it pauses and calls `factorial(3)`, and so on.\n\nThis continues until you hit the base case: `factorial(0)` returns 1 without making another recursive call. Now Python starts \"unwinding\" the stack:\n- `factorial(0)` returns 1\n- `factorial(1)` can now compute `1 * 1 = 1`\n- `factorial(2)` can now compute `2 * 1 = 2`\n- And so on...\n\nAs for why you need `return n * factorial(n-1)` instead of just `factorial(n-1)`: if you don't multiply by n and return it, the function would just call itself and throw away the result! The multiplication is how you actually BUILD the answer on the way back up.\n\nDoes that help clarify? Try drawing it out on paper with `factorial(3)` - it really helps to visualize the stack.",
    "endorsed": true,
    "flagged": false,
    "createdAt": "2025-09-14T17:12:26.013Z",
    "updatedAt": "2025-09-14T18:12:26.013Z"
  },
  {
    "id": "post-3",
    "threadId": "thread-2",
    "authorId": "user-student-4",
    "content": "I had the same confusion! What helped me was realizing that each function call is like a separate sticky note that Python puts on a stack. It can't finish the calculation on one sticky note until it finishes all the ones on top of it.\n\nSo for `factorial(3)`, you get a stack of sticky notes:\n- Note 1: \"return 3 * ???\" (waiting for factorial(2))\n- Note 2: \"return 2 * ???\" (waiting for factorial(1))\n- Note 3: \"return 1 * ???\" (waiting for factorial(0))\n- Note 4: \"return 1\" (base case!)\n\nNow Python works backwards through the stack, filling in the ??? marks.",
    "endorsed": false,
    "flagged": false,
    "createdAt": "2025-09-14T19:12:26.013Z",
    "updatedAt": "2025-09-14T20:12:26.013Z"
  },
  {
    "id": "post-4",
    "threadId": "thread-2",
    "authorId": "user-student-5",
    "content": "The call stack is basically a to-do list that grows as you make more function calls. When you hit the base case, Python starts crossing things off the list from top to bottom.",
    "endorsed": false,
    "flagged": false,
    "createdAt": "2025-09-14T21:12:26.013Z",
    "updatedAt": "2025-09-14T22:12:26.013Z"
  },
  {
    "id": "post-5",
    "threadId": "thread-3",
    "authorId": "user-student-6",
    "content": "Since the assignment says \"implement using the technique we learned this week\" and you learned recursion, you should use recursion. Here's the recursive version:\n\n```python\ndef sum_numbers(n):\n    if n == 0:\n        return 0\n    return n + sum_numbers(n - 1)\n```\n\nBreaking it down:\n- Base case: if n=0, the sum is 0\n- Recursive case: sum from 1 to n = n + sum from 1 to (n-1)\n\nFor example, `sum_numbers(5)` = 5 + sum_numbers(4) = 5 + 4 + 3 + 2 + 1 + 0 = 15.\n\nAs for when to use recursion vs loops in real code: recursion is better for problems with a natural recursive structure (like tree traversal, divide-and-conquer algorithms). For simple iteration like this, loops are usually faster and use less memory because they don't build up a call stack. But for this assignment, use recursion since that's what's being taught!",
    "endorsed": true,
    "flagged": false,
    "createdAt": "2025-09-15T17:12:26.013Z",
    "updatedAt": "2025-09-15T18:12:26.013Z"
  },
  {
    "id": "post-6",
    "threadId": "thread-3",
    "authorId": "user-student-7",
    "content": "I think recursion is overkill for this. The loop is simpler and more efficient. Why make 5 function calls when you can just use a loop?",
    "endorsed": false,
    "flagged": false,
    "createdAt": "2025-09-15T19:12:26.013Z",
    "updatedAt": "2025-09-15T20:12:26.013Z"
  },
  {
    "id": "post-7",
    "threadId": "thread-3",
    "authorId": "user-student-8",
    "content": "@Liam - you're right that loops are more efficient here, but the point of the assignment is to practice recursion. Once you understand the pattern, you can decide which approach is better for different problems. Some problems are WAY easier to think about recursively (like tree problems later in the course).",
    "endorsed": false,
    "flagged": false,
    "createdAt": "2025-09-15T21:12:26.013Z",
    "updatedAt": "2025-09-15T22:12:26.013Z"
  },
  {
    "id": "post-8",
    "threadId": "thread-3",
    "authorId": "user-student-9",
    "content": "Also there's actually a direct formula: sum = n*(n+1)/2. So sum_numbers(5) = 5*6/2 = 15. But yeah, use recursion for the assignment.",
    "endorsed": false,
    "flagged": false,
    "createdAt": "2025-09-15T23:12:26.013Z",
    "updatedAt": "2025-09-16T00:12:26.013Z"
  },
  {
    "id": "post-9",
    "threadId": "thread-4",
    "authorId": "user-ta-1",
    "content": "The issue is in your loop conditions. Look carefully at this line:\n\n```c\nfor (int i = 0; i <= 10; i++) {\n```\n\nIf an array has 10 elements, what are the valid indices? Remember that arrays in C are zero-indexed.\n\nHint: An array declared as `int arr[10]` has elements at indices 0, 1, 2, ..., 9. That's 10 elements total, but the last valid index is 9, not 10.\n\nTry fixing your loop bounds and let me know if that resolves the segfault. Also check your second loop - it has the same issue!",
    "endorsed": false,
    "flagged": false,
    "createdAt": "2025-09-16T17:12:26.013Z",
    "updatedAt": "2025-09-16T18:12:26.013Z"
  },
  {
    "id": "post-10",
    "threadId": "thread-5",
    "authorId": "user-student-11",
    "content": "In Python, the standard is snake_case for variables and functions, PascalCase for classes, and SCREAMING_SNAKE_CASE for constants. So:\n\n```python\nuser_name = \"Alice\"  # variable\nMAX_CONNECTIONS = 100  # constant\n\nclass UserProfile:  # class\n    pass\n```\n\nJava and JavaScript use camelCase for variables/functions and PascalCase for classes. Since you're in a Python course, stick with snake_case for all your variables and function names!",
    "endorsed": true,
    "flagged": false,
    "createdAt": "2025-09-17T17:12:26.013Z",
    "updatedAt": "2025-09-17T18:12:26.013Z"
  },
  {
    "id": "post-11",
    "threadId": "thread-5",
    "authorId": "user-student-12",
    "content": "Check out PEP 8, it's the official Python style guide: https://pep8.org/\n\nIt has all the naming conventions plus other style rules like spacing, line length, etc. Most Python projects follow PEP 8.",
    "endorsed": false,
    "flagged": false,
    "createdAt": "2025-09-17T19:12:26.013Z",
    "updatedAt": "2025-09-17T20:12:26.013Z"
  },
  {
    "id": "post-12",
    "threadId": "thread-6",
    "authorId": "user-ta-1",
    "content": "Great question! The key difference is *how many elements* each algorithm examines.\n\nBinary search eliminates half of the remaining elements with each comparison. So for an array of size 8:\n- Step 1: Check middle (8 elements left)\n- Step 2: Check middle of half (4 elements left)\n- Step 3: Check middle of quarter (2 elements left)\n- Step 4: Check middle of eighth (1 element left)\n\nThat's 4 steps for 8 elements. Notice that 2³ = 8, so log₂(8) = 3... but we needed 4 steps because we include the final check. The pattern is: for n elements, binary search takes at most log₂(n) + 1 steps, which we simplify to O(log n).\n\nLinear search, by contrast, might need to check all n elements in the worst case, so it's O(n).\n\nFor your second question: `range(0, n, 2)` iterates n/2 times, but in Big O we drop constants, so O(n/2) = O(n). We only care about how the runtime grows as n gets large - doubling n still doubles the iterations, even if you're stepping by 2.\n\nDoes this help clarify the difference?",
    "endorsed": true,
    "flagged": false,
    "createdAt": "2025-09-18T17:12:26.013Z",
    "updatedAt": "2025-09-18T18:12:26.013Z"
  },
  {
    "id": "post-13",
    "threadId": "thread-7",
    "authorId": "user-ta-2",
    "content": "This is a great example of choosing data structures based on requirements! For your phone book assignment, you have conflicting goals:\n1. Fast lookup by name: O(1) with hash table\n2. Sorted iteration: Easy with sorted array\n\nSince you need both, here are your options:\n\n**Option 1: Hash table + sort when printing**\n- Lookup: O(1)\n- Insert: O(1)\n- Print sorted: O(n log n) for sorting\n\nThis is good if you do many lookups but print infrequently.\n\n**Option 2: Sorted array + binary search**\n- Lookup: O(log n)\n- Insert: O(n) if you maintain sorted order\n- Print sorted: O(n)\n\nThis is better if you print often.\n\n**Option 3: Use both!** (The best solution for this assignment)\n- Keep a hash table for O(1) lookups\n- Also maintain a sorted list of names\n- When inserting, update both structures\n- This costs more memory but gives you the best of both worlds\n\nFor a production phone book with millions of entries, you'd use a **balanced binary search tree** (like a Red-Black tree or AVL tree) which gives O(log n) lookup AND sorted iteration without needing to sort. Python's built-in `dict` preserves insertion order as of Python 3.7, but doesn't maintain sorted order.\n\nGiven that this is an intro course assignment, I'd suggest Option 1 (hash table + sort when printing) since it's simplest to implement and hash tables are what you're learning.",
    "endorsed": false,
    "flagged": false,
    "createdAt": "2025-09-19T17:12:26.013Z",
    "updatedAt": "2025-09-19T18:12:26.013Z"
  },
  {
    "id": "post-14",
    "threadId": "thread-8",
    "authorId": "user-student-1",
    "content": "For this specific problem (just checking if a path exists), either DFS or BFS works fine. They'll both find a path if one exists.\n\nThe difference matters when you care about the *quality* of the path:\n- BFS finds the shortest path (fewest edges)\n- DFS finds *a* path, but not necessarily the shortest one\n\nBFS explores nodes level by level (all neighbors, then all neighbors of neighbors, etc.). DFS goes deep down one path before backtracking.\n\nSince your autograder accepts both, you're fine with DFS. Just know that if the problem asks for \"shortest path,\" you'd need BFS!",
    "endorsed": false,
    "flagged": false,
    "createdAt": "2025-09-20T17:12:26.013Z",
    "updatedAt": "2025-09-20T18:12:26.013Z"
  },
  {
    "id": "post-15",
    "threadId": "thread-8",
    "authorId": "user-student-2",
    "content": "BFS also uses more memory than DFS because you need to store all nodes at the current level in a queue. DFS only needs to store the path from root to current node on the call stack.",
    "endorsed": false,
    "flagged": false,
    "createdAt": "2025-09-20T19:12:26.013Z",
    "updatedAt": "2025-09-20T20:12:26.013Z"
  },
  {
    "id": "post-16",
    "threadId": "thread-8",
    "authorId": "user-student-3",
    "content": "Wait, I thought DFS was always better because it uses less memory? When would you actually choose BFS over DFS?",
    "endorsed": false,
    "flagged": false,
    "createdAt": "2025-09-20T21:12:26.013Z",
    "updatedAt": "2025-09-20T22:12:26.013Z"
  },
  {
    "id": "post-17",
    "threadId": "thread-8",
    "authorId": "user-student-4",
    "content": "@Raj - BFS is better when you need the shortest path, or when the solution is likely to be close to the start node. DFS is better when solutions are deep in the tree/graph, or when you have memory constraints.",
    "endorsed": false,
    "flagged": false,
    "createdAt": "2025-09-20T23:12:26.013Z",
    "updatedAt": "2025-09-21T00:12:26.013Z"
  },
  {
    "id": "post-18",
    "threadId": "thread-9",
    "authorId": "user-ta-1",
    "content": "The strategy for identifying what to memoize follows this pattern:\n\n1. **What are the parameters to your recursive function?** These become your cache keys.\n   - For Fibonacci: just `n`\n   - For knapsack: `(item_index, remaining_capacity)`\n\n2. **What defines a unique subproblem?** If you're calling `fib(5)` multiple times, you only need to calculate it once and cache the result.\n\n3. **Ask: \"Will I encounter the same parameters again with different call paths?\"** If yes, memoize it.\n\nFor the knapsack problem, you'll have a function like:\n```python\ndef knapsack(items, capacity, index):\n    # Base case\n    if index >= len(items) or capacity == 0:\n        return 0\n    \n    # Check cache\n    if (index, capacity) in memo:\n        return memo[(index, capacity)]\n    \n    # Option 1: Don't take item\n    skip = knapsack(items, capacity, index + 1)\n    \n    # Option 2: Take item (if it fits)\n    take = 0\n    if items[index].weight <= capacity:\n        take = items[index].value + knapsack(items, capacity - items[index].weight, index + 1)\n    \n    # Memoize and return best option\n    memo[(index, capacity)] = max(skip, take)\n    return memo[(index, capacity)]\n```\n\nThe key insight: you memoize on `(index, capacity)` because those are the parameters that define a unique subproblem. You might reach `knapsack(2, 10)` from many different paths, but the answer is always the same given those inputs.\n\nDoes this help? Try identifying the parameters for your homework problem and we can discuss further!",
    "endorsed": true,
    "flagged": true,
    "createdAt": "2025-09-21T17:12:26.013Z",
    "updatedAt": "2025-09-21T18:12:26.013Z"
  },
  {
    "id": "post-19",
    "threadId": "thread-9",
    "authorId": "user-student-6",
    "content": "This is really helpful! So basically you memoize on whatever makes a subproblem unique. For coin change, that would be (amount, coin_index)?",
    "endorsed": false,
    "flagged": false,
    "createdAt": "2025-09-21T19:12:26.013Z",
    "updatedAt": "2025-09-21T20:12:26.013Z"
  },
  {
    "id": "post-20",
    "threadId": "thread-9",
    "authorId": "user-student-7",
    "content": "I find it easier to use bottom-up DP (tabulation) instead of top-down with memoization. You build a table and fill it in order, so you don't need to worry about cache keys. But both approaches work!",
    "endorsed": false,
    "flagged": false,
    "createdAt": "2025-09-21T21:12:26.013Z",
    "updatedAt": "2025-09-21T22:12:26.013Z"
  },
  {
    "id": "post-21",
    "threadId": "thread-10",
    "authorId": "user-student-8",
    "content": "I had the same confusion with double rotations! What helped me is drawing it out step by step.\n\nFor a left-right case, the issue is that a single rotation makes the imbalance worse. Try this example:\n\n```\n    3\n   /\n  1\n   \\\n    2\n```\n\nIf you do a right rotation on 3, you get:\n```\n  1\n   \\\n    3\n   /\n  2\n```\n\nNow it's even more unbalanced! That's why you first do a left rotation on node 1:\n```\n    3\n   /\n  2\n /\n1\n```\n\nThen a right rotation on node 3 gives you the balanced tree:\n```\n  2\n /  \\\n1    3\n```\n\nSo the first rotation \"straightens\" the zig-zag into a straight line, then the second rotation balances it.",
    "endorsed": false,
    "flagged": false,
    "createdAt": "2025-09-22T17:12:26.013Z",
    "updatedAt": "2025-09-22T18:12:26.013Z"
  },
  {
    "id": "post-22",
    "threadId": "thread-10",
    "authorId": "user-student-9",
    "content": "For identifying which case in code, you check the balance factors of both the node and its child. If the node has balance factor +2 (left-heavy) and the left child has balance factor -1 (right-heavy), that's a left-right case requiring double rotation.",
    "endorsed": false,
    "flagged": false,
    "createdAt": "2025-09-22T19:12:26.013Z",
    "updatedAt": "2025-09-22T20:12:26.013Z"
  },
  {
    "id": "post-23",
    "threadId": "thread-11",
    "authorId": "user-ta-3",
    "content": "Excellent question! LIATE is a mnemonic for choosing u in integration by parts:\n\n**L** - Logarithmic (ln x, log x)\n**I** - Inverse trig (arcsin, arctan, etc.)\n**A** - Algebraic (x, x², polynomials)\n**T** - Trigonometric (sin, cos, tan)\n**E** - Exponential (eˣ, aˣ)\n\nYou choose u as whichever function appears FIRST in this list, and dv is what's left.\n\nFor ∫ x·ln(x) dx:\n- ln(x) is Logarithmic (L)\n- x is Algebraic (A)\n- L comes before A, so u = ln(x), dv = x dx\n\nThis gives:\n- u = ln(x), so du = (1/x) dx\n- dv = x dx, so v = x²/2\n\nNow apply the formula:\n∫ x·ln(x) dx = uv - ∫ v du\n= ln(x)·(x²/2) - ∫ (x²/2)·(1/x) dx\n= (x²/2)·ln(x) - ∫ (x/2) dx\n= (x²/2)·ln(x) - x²/4 + C\n\nThe reason LIATE works is that differentiating functions earlier in the list usually simplifies them (ln(x) becomes 1/x), while integrating functions later in the list is straightforward.\n\nYour instinct was correct - choosing u = ln(x) was the right move! The key is that you CAN integrate x (to get x²/2), but integrating ln(x) directly is harder.",
    "endorsed": true,
    "flagged": false,
    "createdAt": "2025-09-23T17:12:26.013Z",
    "updatedAt": "2025-09-23T18:12:26.013Z"
  },
  {
    "id": "post-24",
    "threadId": "thread-11",
    "authorId": "user-student-11",
    "content": "Thanks! So the LIATE rule helps you avoid choosing u = x because then du = dx and you're stuck integrating ln(x) which is messy. Got it!",
    "endorsed": false,
    "flagged": false,
    "createdAt": "2025-09-23T19:12:26.013Z",
    "updatedAt": "2025-09-23T20:12:26.013Z"
  },
  {
    "id": "post-25",
    "threadId": "thread-11",
    "authorId": "user-student-12",
    "content": "Wait, can you actually integrate ln(x) directly? I thought you needed integration by parts for that too?",
    "endorsed": false,
    "flagged": false,
    "createdAt": "2025-09-23T21:12:26.013Z",
    "updatedAt": "2025-09-23T22:12:26.013Z"
  },
  {
    "id": "post-26",
    "threadId": "thread-12",
    "authorId": "user-student-13",
    "content": "Yes, you're exactly right! u-substitution IS the chain rule in reverse.\n\nFor your second question about ∫ x·cos(x²) dx where you have x dx instead of 2x dx:\n\nYou can still use u-substitution! The trick is to adjust for the missing constant:\n- Let u = x²\n- Then du = 2x dx\n- So x dx = (1/2) du\n\nNow substitute:\n∫ x·cos(x²) dx = ∫ cos(u) · (1/2) du = (1/2) ∫ cos(u) du = (1/2) sin(u) + C = (1/2) sin(x²) + C\n\nThe key is recognizing that you can factor out constants to make the substitution work. If you see x dx and need 2x dx, just multiply by 1/2 to compensate!",
    "endorsed": false,
    "flagged": false,
    "createdAt": "2025-09-24T17:12:26.013Z",
    "updatedAt": "2025-09-24T18:12:26.013Z"
  },
  {
    "id": "post-27",
    "threadId": "thread-13",
    "authorId": "user-student-14",
    "content": "I made a flowchart for myself that helps:\n\n1. First, always check divergence test: if lim aₙ ≠ 0, it diverges\n2. If it's a p-series (Σ 1/nᵖ), use p-series test: converges if p > 1\n3. If it looks like a geometric series, use geometric test\n4. If it has factorials or exponentials, try ratio test\n5. If it has nth roots, try root test\n6. For complicated fractions, try comparison or limit comparison\n7. If it alternates signs, try alternating series test\n\nFor your series Σ(n²/eⁿ), I'd use the ratio test because of the exponential. And yes, if the ratio test gives L=1, it's inconclusive - you'd need to try a different test.",
    "endorsed": false,
    "flagged": false,
    "createdAt": "2025-09-25T17:12:26.013Z",
    "updatedAt": "2025-09-25T18:12:26.013Z"
  },
  {
    "id": "post-28",
    "threadId": "thread-13",
    "authorId": "user-student-1",
    "content": "Just memorize all the tests and you'll be fine. The exam will probably test each one at least once.",
    "endorsed": false,
    "flagged": true,
    "createdAt": "2025-09-25T19:12:26.013Z",
    "updatedAt": "2025-09-25T20:12:26.013Z"
  },
  {
    "id": "post-29",
    "threadId": "thread-13",
    "authorId": "user-student-2",
    "content": "For the ratio test giving L=1, you can sometimes use the integral test instead. That's what I did on the practice problems.",
    "endorsed": false,
    "flagged": false,
    "createdAt": "2025-09-25T21:12:26.013Z",
    "updatedAt": "2025-09-25T22:12:26.013Z"
  },
  {
    "id": "post-30",
    "threadId": "thread-13",
    "authorId": "user-student-3",
    "content": "The professor posted a decision tree on Canvas under Files > Resources. It's really helpful for choosing which test to use!",
    "endorsed": false,
    "flagged": false,
    "createdAt": "2025-09-25T23:12:26.013Z",
    "updatedAt": "2025-09-26T00:12:26.013Z"
  },
  {
    "id": "post-31",
    "threadId": "thread-14",
    "authorId": "user-ta-2",
    "content": "Your algebra is correct! Let me verify your partial fraction values by checking your work:\n\nYou found A = 14/5 and B = 1/5. Let's verify by combining them back:\n\nA/(x-3) + B/(x+2) = (14/5)/(x-3) + (1/5)/(x+2)\n\nFinding common denominator:\n= [14(x+2) + 1(x-3)] / [5(x-3)(x+2)]\n= [14x + 28 + x - 3] / [5(x²-x-6)]\n= [15x + 25] / [5(x²-x-6)]\n= [5(3x + 5)] / [5(x²-x-6)]\n= (3x + 5) / (x²-x-6) ✓\n\nYour values are correct! The reason it seemed wrong when you checked might be an algebra error in your verification. Your original approach using x=3 and x=-2 was perfect.\n\nNow you can integrate:\n∫ (3x+5)/(x²-x-6) dx = ∫ [(14/5)/(x-3) + (1/5)/(x+2)] dx\n= (14/5)ln|x-3| + (1/5)ln|x+2| + C\n\nGreat work on the partial fractions setup!",
    "endorsed": false,
    "flagged": false,
    "createdAt": "2025-09-26T17:12:26.013Z",
    "updatedAt": "2025-09-26T18:12:26.013Z"
  },
  {
    "id": "post-32",
    "threadId": "thread-14",
    "authorId": "user-student-5",
    "content": "I always mess up the algebra when checking my partial fractions. It's easier to just plug in x values to solve for A and B, then trust that they're right without verifying.",
    "endorsed": false,
    "flagged": false,
    "createdAt": "2025-09-26T19:12:26.013Z",
    "updatedAt": "2025-09-26T20:12:26.013Z"
  },
  {
    "id": "post-33",
    "threadId": "thread-14",
    "authorId": "user-student-6",
    "content": "The trick for checking: plug your A and B values back into the equation 3x+5 = A(x+2) + B(x-3) and expand. If both sides match for all x, you're good!",
    "endorsed": false,
    "flagged": false,
    "createdAt": "2025-09-26T21:12:26.013Z",
    "updatedAt": "2025-09-26T22:12:26.013Z"
  },
  {
    "id": "post-34",
    "threadId": "thread-15",
    "authorId": "user-ta-2",
    "content": "Great observation! You're right that it's an ∞/∞ indeterminate form, which means L'Hopital's rule applies.\n\nThe divide-by-highest-power method works great for **polynomials** because dividing by x^n turns higher powers into simpler fractions. But for exponentials like e^x, dividing doesn't simplify things the same way.\n\nWhen you have e^x in the limit, L'Hopital's is usually cleaner. Let's apply it:\n\nlim(x→∞) (e^x - e^(-x))/(e^x + e^(-x))\n\nTake derivatives of top and bottom:\n= lim(x→∞) (e^x + e^(-x))/(e^x - e^(-x))\n\nHmm, that's still ∞/∞. Apply L'Hopital's again:\n= lim(x→∞) (e^x - e^(-x))/(e^x + e^(-x))\n\nWait, we're back where we started! Let me show you a better approach:\n\nDivide numerator and denominator by e^x:\nlim(x→∞) (e^x - e^(-x))/(e^x + e^(-x)) · (1/e^x)/(1/e^x)\n= lim(x→∞) (1 - e^(-2x))/(1 + e^(-2x))\n\nAs x→∞, e^(-2x)→0, so:\n= (1 - 0)/(1 + 0) = 1\n\nSo the answer is 1! The key insight: divide by the dominant exponential term (e^x), not by a power of x.",
    "endorsed": true,
    "flagged": false,
    "createdAt": "2025-09-27T17:12:26.013Z",
    "updatedAt": "2025-09-27T18:12:26.013Z"
  },
  {
    "id": "post-35",
    "threadId": "thread-16",
    "authorId": "user-ta-3",
    "content": "The 3-SAT to SUBSET-SUM reduction is tricky! Here's the key insight:\n\n**Big picture:** You need to construct a set of integers such that there exists a subset summing to a target value T if and only if the 3-SAT formula is satisfiable.\n\n**Construction strategy:**\n1. For each boolean variable xᵢ, create two numbers: one representing xᵢ=true and one representing xᵢ=false\n2. For each clause Cⱼ, create numbers that track whether the clause is satisfied\n3. The target sum T should force exactly one of {xᵢ=true, xᵢ=false} to be chosen for each variable AND require each clause to be satisfied\n\n**Example with one variable and one clause:**\nFormula: (x₁ ∨ ¬x₁)  (trivially satisfiable)\n\nCreate base-10 numbers where each digit position represents something:\n- Position 1: variable x₁\n- Position 0: clause C₁\n\nNumbers:\n- x₁=true: 11 (satisfies var x₁, satisfies clause C₁)\n- x₁=false: 01 (doesn't satisfy var, satisfies clause C₁ via ¬x₁)\n\nTarget T: 11 (must pick one value for x₁, must satisfy C₁)\n\nThe full reduction uses this idea but with more complex digit encoding. I recommend looking at the textbook example (Section 7.5) which walks through the construction in detail.\n\nKey question to think about: How do you ensure exactly one of {xᵢ=true, xᵢ=false} is chosen in the subset? What constraint on T forces this?",
    "endorsed": false,
    "flagged": false,
    "createdAt": "2025-09-28T17:12:26.013Z",
    "updatedAt": "2025-09-28T18:12:26.013Z"
  },
  {
    "id": "post-36",
    "threadId": "thread-17",
    "authorId": "user-student-9",
    "content": "I struggled with this proof too! The key insight is that the greedy algorithm selects edges that form a **matching** - a set of edges with no shared vertices.\n\nWhen you pick an edge (u,v) and add both endpoints to the cover, you're \"covering\" that edge. Any optimal vertex cover must include at least one endpoint from that edge (otherwise the edge wouldn't be covered).\n\nSo if your greedy algorithm selects k edges forming a matching, you add 2k vertices. But the optimal cover must include at least k vertices (one from each edge in the matching). Therefore:\n\ngreedy_size = 2k ≤ 2 × optimal_size\n\nThat's the 2-approximation!",
    "endorsed": false,
    "flagged": false,
    "createdAt": "2025-09-29T17:12:26.013Z",
    "updatedAt": "2025-09-29T18:12:26.013Z"
  },
  {
    "id": "post-37",
    "threadId": "thread-17",
    "authorId": "user-student-10",
    "content": "Can we do better than 2-approximation? I read somewhere that there's no polynomial-time algorithm with approximation ratio less than 2 unless P=NP. Is that true?",
    "endorsed": false,
    "flagged": false,
    "createdAt": "2025-09-29T19:12:26.013Z",
    "updatedAt": "2025-09-29T20:12:26.013Z"
  },
  {
    "id": "post-38",
    "threadId": "thread-17",
    "authorId": "user-student-11",
    "content": "@Isabella - Not quite. The best known hardness result says you can't do better than 1.36-approximation in polynomial time (assuming certain complexity assumptions). But 2-approximation is easy to achieve with the greedy algorithm, so that's what we focus on in this course.",
    "endorsed": true,
    "flagged": false,
    "createdAt": "2025-09-29T21:12:26.013Z",
    "updatedAt": "2025-09-29T22:12:26.013Z"
  },
  {
    "id": "post-39",
    "threadId": "thread-17",
    "authorId": "user-student-12",
    "content": "The lecture slides have a nice diagram showing the matching and why OPT must cover at least one endpoint of each edge. That visual really helped me understand the proof.",
    "endorsed": false,
    "flagged": false,
    "createdAt": "2025-09-29T23:12:26.013Z",
    "updatedAt": "2025-09-30T00:12:26.013Z"
  },
  {
    "id": "post-40",
    "threadId": "thread-18",
    "authorId": "user-ta-2",
    "content": "You've correctly identified the problem: greedy coloring is highly dependent on the **order** you process vertices!\n\nFor k=3 coloring specifically, the decision problem (\"can this graph be colored with 3 colors?\") is NP-complete, so there's no known polynomial-time algorithm that always finds a 3-coloring when one exists.\n\nHere are some heuristics that improve greedy coloring:\n\n**1. Order by degree (largest first)**\n```python\ndef greedy_color_ordered(graph):\n    # Sort vertices by degree (descending)\n    vertices = sorted(graph.keys(), key=lambda v: len(graph[v]), reverse=True)\n    colors = {}\n    for node in vertices:\n        neighbor_colors = {colors[n] for n in graph[node] if n in colors}\n        for color in range(len(graph)):\n            if color not in neighbor_colors:\n                colors[node] = color\n                break\n    return colors\n```\n\nThis heuristic colors high-degree vertices first (they're the most constrained), which often reduces the total colors needed.\n\n**2. For your specific problem (3-coloring decision):**\nIf the problem asks \"does a 3-coloring exist,\" you might need backtracking:\n- Try coloring vertices with colors {0,1,2}\n- If you get stuck, backtrack and try a different color\n- This is exponential in worst case but works for small graphs\n\n**3. For cycle graphs specifically:**\nA cycle of length n is:\n- 2-colorable if n is even\n- 3-colorable if n is odd\n\nSo a cycle of 5 nodes (odd) needs exactly 3 colors, and you should be able to color it greedily if you process vertices in cycle order.\n\nFor the midterm, the largest-degree-first heuristic is probably what they're looking for. It doesn't guarantee optimal, but it's a good improvement over random order!",
    "endorsed": false,
    "flagged": false,
    "createdAt": "2025-09-30T17:12:26.013Z",
    "updatedAt": "2025-09-30T18:12:26.013Z"
  },
  {
    "id": "post-41",
    "threadId": "thread-18",
    "authorId": "user-student-14",
    "content": "Thanks! So for a cycle graph, I should just process vertices in order around the cycle rather than random order. That makes sense.",
    "endorsed": false,
    "flagged": false,
    "createdAt": "2025-09-30T19:12:26.013Z",
    "updatedAt": "2025-09-30T20:12:26.013Z"
  },
  {
    "id": "post-42",
    "threadId": "thread-19",
    "authorId": "user-ta-1",
    "content": "This is a conceptual question about what E and V actually represent physically, not just mathematically.\n\nThink about what happens when you move a test charge in an electric field:\n- The **electric field E** tells you the force per unit charge: F = qE\n- The **electric potential V** tells you the potential energy per unit charge: U = qV\n\nThey're related but describe different aspects:\n\n**Electric field E:**\n- Vector (has direction)\n- Represents force on a charge\n- Units: N/C or V/m\n- Tells you \"which way would a positive charge accelerate?\"\n\n**Electric potential V:**\n- Scalar (just a number)\n- Represents energy of a charge at a location\n- Units: Volts (J/C)\n- Tells you \"how much work to bring a charge here from infinity?\"\n\nThe relationship E = -∇V means: the electric field points in the direction of steepest *decrease* in potential (the negative gradient).\n\nAnalogy: Think of potential like altitude on a hill, and field like the slope:\n- High altitude = high potential\n- Steep slope = strong field\n- Slope points downhill = field points toward lower potential\n\nAs for which to use when: it depends on the problem. If you care about forces and motion, use E. If you care about energy and work, use V. Often it's easier to calculate V first (especially with symmetry), then take the gradient to find E.",
    "endorsed": true,
    "flagged": true,
    "createdAt": "2025-10-01T17:12:26.013Z",
    "updatedAt": "2025-10-01T18:12:26.013Z"
  },
  {
    "id": "post-43",
    "threadId": "thread-19",
    "authorId": "user-student-2",
    "content": "The hill analogy really helps! So potential is like height, and field is like the steepness of the slope. A ball would roll downhill (toward lower potential), just like a positive charge moves toward lower potential.",
    "endorsed": false,
    "flagged": false,
    "createdAt": "2025-10-01T19:12:26.013Z",
    "updatedAt": "2025-10-01T20:12:26.013Z"
  },
  {
    "id": "post-44",
    "threadId": "thread-20",
    "authorId": "user-student-3",
    "content": "Yes, KCL is exactly conservation of charge! Charge can't just pile up at a node (assuming steady-state DC circuits).\n\nThink of it like water flowing through pipes: the amount of water entering a junction must equal the amount leaving, otherwise water would accumulate there. Same with electric charge - it has to keep flowing.\n\nFor your sign convention question: currents flowing INTO a node are positive, currents flowing OUT are negative. So:\n\nI₁ (in) - I₂ (out) - I₃ (out) = 0\n\nWhich gives: I₁ = I₂ + I₃\n\nThis makes intuitive sense: the current coming in splits into two currents going out.\n\nThe direction arrow on a circuit diagram just defines the reference direction. If you calculate a negative current, it means the actual current flows opposite to your assumed direction. Your answer is still correct!",
    "endorsed": true,
    "flagged": false,
    "createdAt": "2025-10-02T17:12:26.013Z",
    "updatedAt": "2025-10-02T18:12:26.013Z"
  },
  {
    "id": "post-45",
    "threadId": "thread-21",
    "authorId": "user-student-4",
    "content": "If the problem doesn't specify θ, you usually assume the magnetic field is perpendicular to the loop (θ = 0°), which gives maximum flux Φ = BA.\n\nBut yes, if cos(θ) = 0 (meaning θ = 90°), the magnetic field is parallel to the loop's surface, and the flux is zero. This makes physical sense: magnetic field lines aren't passing \"through\" the loop, they're going along it, so there's no flux.\n\nFor your specific problem, if they don't mention angle, assume perpendicular: Φ = BA = (0.2 T)(7.85×10⁻³ m²) = 1.57×10⁻³ Wb.",
    "endorsed": true,
    "flagged": false,
    "createdAt": "2025-10-03T17:12:26.013Z",
    "updatedAt": "2025-10-03T18:12:26.013Z"
  },
  {
    "id": "post-46",
    "threadId": "thread-22",
    "authorId": "user-ta-2",
    "content": "Great question about structure! The literature review can be either a separate section OR part of the introduction, depending on the field and the length of your paper.\n\nFor a typical undergraduate research paper (8-12 pages), I recommend:\n\n**Introduction:**\n- Context and background (1 paragraph)\n- Research question/thesis (1 paragraph)\n- Brief overview of your approach (1 paragraph)\n\n**Literature Review** (separate section):\n- Group sources by theme, not by author\n- Show how existing research relates to your question\n- Identify gaps that your work addresses\n\n**Methodology, Results, Discussion, Conclusion:** (as specified)\n\nFor the lit review specifically, **group by theme** rather than summarizing each source separately. For example:\n\n**❌ Bad (author-by-author):**\n\"Smith (2019) found X. Jones (2020) found Y. Brown (2021) found Z.\"\n\n**✓ Good (thematic):**\n\"Several researchers have found that social media affects mental health. Studies focusing on teenagers (Smith 2019, Jones 2020) suggest negative effects, while research on adults (Brown 2021) shows mixed results.\"\n\nAs for length: 3 pages out of 6 total is too much. Aim for 1.5-2 pages for the lit review, leaving more space for your own analysis, methodology, and discussion.\n\nYour literature review should *synthesize* existing research, not just summarize it. Show how sources relate to each other and to your research question!",
    "endorsed": false,
    "flagged": false,
    "createdAt": "2025-10-04T17:12:26.013Z",
    "updatedAt": "2025-10-04T18:12:26.013Z"
  },
  {
    "id": "post-47",
    "threadId": "thread-22",
    "authorId": "user-student-6",
    "content": "That thematic vs author-by-author example is super helpful! I've been doing it wrong and just going through each source one by one.",
    "endorsed": false,
    "flagged": false,
    "createdAt": "2025-10-04T19:12:26.013Z",
    "updatedAt": "2025-10-04T20:12:26.013Z"
  },
  {
    "id": "post-48",
    "threadId": "thread-22",
    "authorId": "user-student-7",
    "content": "Also, your lit review should end with identifying a gap or question that your research addresses. That creates a smooth transition to your methodology section.",
    "endorsed": false,
    "flagged": false,
    "createdAt": "2025-10-04T21:12:26.013Z",
    "updatedAt": "2025-10-04T22:12:26.013Z"
  },
  {
    "id": "post-49",
    "threadId": "thread-22",
    "authorId": "user-student-8",
    "content": "The Writing Center has a handout on lit reviews that's really good. They also do free appointments if you want someone to look at your draft!",
    "endorsed": false,
    "flagged": false,
    "createdAt": "2025-10-04T23:12:26.013Z",
    "updatedAt": "2025-10-05T00:12:26.013Z"
  },
  {
    "id": "post-50",
    "threadId": "thread-23",
    "authorId": "user-ta-3",
    "content": "You don't need to cite every single sentence if the entire paragraph is based on one source. However, you do need to make it clear WHERE the information is coming from.\n\nHere's a better approach:\n\n**Option 1: Signal phrase at start + citation at end**\n\"According to Johnson (2020), climate change significantly affects agriculture. Rising temperatures reduce crop yields, especially for wheat and rice. These effects are more pronounced in developing countries.\"\n\n**Option 2: Citation at end if context is clear**\n\"Climate change significantly affects agriculture. Rising temperatures reduce crop yields, especially for wheat and rice, with more pronounced effects in developing countries (Johnson 2020).\"\n\nThe key is that a reader should always know whether they're reading YOUR ideas or someone else's.\n\n**Common knowledge rule:** If an average person could verify the fact in multiple general sources without specialized research, it's common knowledge and doesn't need citation. Examples:\n- \"Shakespeare wrote Romeo and Juliet\" - no citation needed\n- \"The Earth orbits the Sun\" - no citation needed  \n- \"The 2020 election had record turnout\" - needs citation (specific data)\n- \"Climate change is happening\" - no citation (general fact)\n- \"Climate change will increase temperatures by 2°C by 2050\" - needs citation (specific claim)\n\nWhen in doubt, cite it! Over-citing is better than under-citing in academic writing.",
    "endorsed": true,
    "flagged": false,
    "createdAt": "2025-10-05T17:12:26.013Z",
    "updatedAt": "2025-10-05T18:12:26.013Z"
  },
  {
    "id": "post-51",
    "threadId": "thread-23",
    "authorId": "user-student-10",
    "content": "Thanks! So basically if I'm paraphrasing a whole paragraph from one source, I can introduce it with \"According to X\" and then cite at the end, rather than citing every sentence.",
    "endorsed": false,
    "flagged": false,
    "createdAt": "2025-10-05T19:12:26.013Z",
    "updatedAt": "2025-10-05T20:12:26.013Z"
  },
  {
    "id": "post-52",
    "threadId": "thread-23",
    "authorId": "user-student-11",
    "content": "I always err on the side of citing more rather than less. Plagiarism is serious and it's not worth the risk of leaving out a citation!",
    "endorsed": false,
    "flagged": false,
    "createdAt": "2025-10-05T21:12:26.013Z",
    "updatedAt": "2025-10-05T22:12:26.013Z"
  },
  {
    "id": "post-53",
    "threadId": "thread-24",
    "authorId": "user-student-12",
    "content": "Your thesis is too broad and not arguable because it's just stating that social media has effects (which is obviously true). A good thesis needs to:\n\n1. Be specific (focus on one aspect)\n2. Be arguable (someone could disagree)\n3. Preview your argument\n\nHere are some ways to narrow it:\n\n**Focus on one effect:**\n\"Social media algorithms that prioritize engagement over accuracy contribute to the spread of political misinformation, which undermines democratic discourse.\"\n\n**Focus on one platform + one outcome:**\n\"Instagram's emphasis on curated visual content creates unrealistic beauty standards that negatively impact teenage girls' self-esteem.\"\n\n**Focus on one solution:**\n\"While social media platforms face criticism for mental health impacts, implementing digital literacy education in schools is more effective than regulating platform design.\"\n\nNotice how each of these:\n- Picks ONE specific aspect of social media\n- Makes a claim someone could argue against\n- Gives direction to your paper\n\nYou mentioned mental health, misinformation, connecting people, and business - that's 4 different papers! Pick ONE angle and dive deep into it for 5 pages. Quality over quantity!",
    "endorsed": false,
    "flagged": false,
    "createdAt": "2025-10-06T17:12:26.013Z",
    "updatedAt": "2025-10-06T18:12:26.013Z"
  }
]